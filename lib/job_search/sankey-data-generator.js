const { Link, Node } = require("../../components/sankey/types");
const { jobSearchEvents } = require("./private-events");
const { EventType, JobData } = require("./types");
const fs = require("fs");

/**
 * @fileoverview A script to convert job events into diagram data and write it to `OUTPUT_FILE`.
 *
 * <p>This script is used to keep job events private.
 *
 * <p>To run this script, cd into the root project directory, then use:
 * <code>
 *   node lib/job_search/sankey-data-generator.js
 * </code>
 *
 * <p>`jobsearchEvents' is formatted like this:
 * <code>
 * const jobSearchEvents: {
 *     job: string;
 *     date: Date;
 *     eventType: EventType;
 *  } = [
 *     {
 *       job: "Facebook",
 *       date: new Date("1-01-2023"),
 *       eventType: EventType.Applied
 *     },
 *     {
 *       job: "Facebook",
 *       date: new Date("1-02-2023"),
 *       eventType: EventType.Rejected
 *     },
 *     {
 *       job: "Apple",
 *       date: new Date("1-01-2023"),
 *       eventType: EventType.Applied
 *     },
 *     {
 *       job: "Apple",
 *       date: new Date("1-07-2023"),
 *       eventType: EventType.RecruiterInterview
 *     },
 * ];
 * module.exports = { jobSearchEvents };
 * </code>
 */

/** Location to write the output. */
const OUTPUT_FILE = "components/job_search/job-search-sankey-data.json";

/**
 * Event types that should have a single node in the diagram shared by all ancestors.
 */
const SHARED_EVENT_TYPES = [
  EventType.VirtualOnsiteInterview,
  EventType.Rejected,
];

/** Nodes in the order that they will be rendered. */
const ORDERED_NODE_NAMES = [
  "Applied",
  "Applied;Recruiter Interview",
  "Applied;Recruiter Interview;Rejected By Me",
  "Applied;Recruiter Interview;Technical Interview",
  "Applied;Technical Interview",
  "Onsite Interview;Manager Interview",
  "Onsite Interview",
  "Onsite Interview;Manager Interview;2nd Technical",
  "Onsite Interview;Manager Interview;2nd Technical;Offer",
  "Applied;Recruiter Interview;Technical Interview;Manager Interview",
  "Applied;Recruiter Interview;Manager Interview",
  "Applied;Recruiter Interview;Manager Interview;Technical Interview",
  "Applied;Recruiter Interview;Manager Interview;Technical Interview;2nd Technical",
  "Applied;Manager Interview",
  "Applied;Rejected By Me",
  "Rejected",
];

/**
 * @param {!Array<!Array<!EventType>} eventTypeEdges
 * @return {!Array<!Node>}
 */

function createNodes(eventTypeEdges) {
  const autogeneratedNodeNames = getAutogeneratedNodeNames(eventTypeEdges);
  if (ORDERED_NODE_NAMES.length !== autogeneratedNodeNames.length) {
    let errorMessage = `ORDERED_NODE_NAMES length does not match autogenerated names length\n`;
    errorMessage += `\tORDERED_NODE_NAMES.length=${ORDERED_NODE_NAMES.length}\n`;
    errorMessage += `\tautogeneratedNodeNames.length=${autogeneratedNodeNames.length}\n`;
    errorMessage += `Expected to be included in ORDERED_NODE_NAMES:\n`;
    const excludedFromOrdered = autogeneratedNodeNames.filter(
      (name) => !ORDERED_NODE_NAMES.includes(name)
    );
    excludedFromOrdered.forEach((name) => (errorMessage += `\t${name}\n`));
    errorMessage += `Expected to be included in autogenerated names:\n`;
    const excludedFromAutogenerated = ORDERED_NODE_NAMES.filter(
      (name) => !autogeneratedNodeNames.includes(name)
    );
    excludedFromAutogenerated.forEach(
      (name) => (errorMessage += `\t${name}\n`)
    );
    throw Error(errorMessage);
  }
  return ORDERED_NODE_NAMES.map((name) => {
    const eventTypeEdge = getEventTypesFromEdgeKey(name);
    const category = getLast(eventTypeEdge);
    return { name, category, count: 0 };
  });
}

/**
 * @param {!Array<!Array<!EventType>>} eventTypeEdges
 */

function getAutogeneratedNodeNames(eventTypeEdges) {
  // Start with root nodes
  const nodeNameSet = new Set(
    eventTypeEdges.map((eventTypeEdge) => eventTypeEdge[0])
  );
  for (const eventTypeEdge of eventTypeEdges) {
    nodeNameSet.add(getNodeName(eventTypeEdge));
  }
  return Array.from(nodeNameSet);
}

/**
 * @param {string} name
 * @return {!Array<!EventType>}
 */
function getEventTypesFromEdgeKey(name) {
  return name.split(";");
}

/**
 * @param {!Array<!EventType>} eventTypeEdge
 * @return {string}
 */
function getNodeName(eventTypeEdge) {
  if (SHARED_EVENT_TYPES.includes(getLast(eventTypeEdge))) {
    return getLast(eventTypeEdge);
  }
  const firstSharedIndex = eventTypeEdge.findIndex((eventType) =>
    SHARED_EVENT_TYPES.includes(eventType)
  );
  if (firstSharedIndex !== -1) {
    eventTypeEdge = [...eventTypeEdge];
    eventTypeEdge.splice(0, firstSharedIndex);
  }
  return eventTypeEdge.join(";");
}

/**
 * @param {!Array<!JobData>} jobDatas
 * @param {!Array<!Node>} nodes
 * @param {!Array<!Array<!EventType>>} eventTypeEdges
 * @return {!Array<!Link>}
 */
function createLinks(jobDatas, nodes, eventTypeEdges) {
  const links = [];
  for (const eventTypeEdge of eventTypeEdges) {
    const matchingJobDatas = jobDatas.filter((jobData) =>
      isMatchingJobData(jobData, eventTypeEdge)
    );
    // The source is everything but the last event
    const source = getNodeName(eventTypeEdge.slice(0, -1));
    const target = getNodeName(eventTypeEdge);
    const value = matchingJobDatas.length;
    links.push({ source, target, value });
    const targetNode = nodes.find((node) => node.name === target);
    if (!targetNode) {
      throw Error(`Could not find node with node name: ${target}`);
    }
    targetNode.count += value;

    if (source === EventType.Applied) {
      nodes.find((node) => node.name === EventType.Applied).count += value;
    }
  }
  return links;
}

/**
 * @return {!Array{!JobData>}}
 */
function createJobDatas() {
  const jobs = Array.from(
    new Set(jobSearchEvents.map((jobSearchEvent) => jobSearchEvent.job))
  );
  const jobToJobEvents = new Map(
    jobs.map((job) => [
      job,
      jobSearchEvents.filter((jobSearchEvent) => jobSearchEvent.job === job),
    ])
  );
  return Array.from(jobToJobEvents.entries()).map(([job, jobSearchEvents]) => ({
    job,
    jobSearchEvents,
  }));
}

/**
 * Create edges that describe all links in the diagram.
 *
 * <p>An edge describes the link that points to the node name composed of the event types in the edge.
 *
 * @param {!Array<!JobData>} jobDatas
 * @return {!Array<!Array<!EventType>>}
 */
function createEventTypeEdges(jobDatas) {
  /**
   * @param {!Array<!EventType>} eventTypeEdge
   * @return {string}
   */
  function getEdgeName(eventTypeEdge) {
    const firstSharedIndex = eventTypeEdge.findIndex((eventType) =>
      SHARED_EVENT_TYPES.includes(eventType)
    );
    // Special case: There is a shared node within the source path (not the target)
    if (
      firstSharedIndex !== -1 &&
      firstSharedIndex < eventTypeEdge.length - 1
    ) {
      // Make a copy so that we don't modify the input
      eventTypeEdge = [...eventTypeEdge];
      // Remove event types before the shared node
      eventTypeEdge.splice(0, firstSharedIndex);
    }
    return eventTypeEdge.join(";");
  }

  const eventTypeEdges = [];
  const eventTypeEdgeSet = new Set();
  for (const jobData of jobDatas) {
    for (let i = 1; i < jobData.jobSearchEvents.length; i++) {
      const eventTypes = jobData.jobSearchEvents
        .slice(0, i + 1)
        .map((jobSearchEvent) => jobSearchEvent.eventType);
      const edgeKey = getEdgeName(eventTypes);
      if (!eventTypeEdgeSet.has(edgeKey)) {
        eventTypeEdgeSet.add(edgeKey);
        eventTypeEdges.push(getEventTypesFromEdgeKey(edgeKey));
      }
    }
  }
  return eventTypeEdges;
}

/**
 * Nodes that link to the "No Reply" node.
 *
 * <p>TODO: Calculate this rather than hardcode.
 */
const nodeNamesWithNoReply = [
  "Applied",
  "Applied;Recruiter Interview",
  "Applied;Manager Interview",
  "Applied;Recruiter Interview;Technical Interview",
  "Onsite Interview;Manager Interview",
];

/**
 * Adds a "No Reply" node, and links to the "No Reply" node from nodes with unresolved threads.
 *
 * <p>Also handles "No Reply"'s from the Applied node (This is a special case because Applied is the root node).
 * @param {!Array<!Node>} nodes
 * @param {!Array<!Link>} links
 */
function addNoReplyNode() {
  const realApplyCount = jobSearchEvents.filter(
    (event) => event.eventType === EventType.Applied
  ).length;
  const appliedNode = nodes.find((node) => node.name === EventType.Applied);
  if (!appliedNode) {
    throw Error(`Expected EventType.Applied node to exist`);
  }
  appliedNode.count = realApplyCount;

  const NO_REPLY = "No Reply";
  let noReplyTotal = 0;

  const nodesWithNoReply = nodes.filter((node) =>
    nodeNamesWithNoReply.includes(node.name)
  );
  for (const node of nodesWithNoReply) {
    const downstreamLinks = links.filter((link) => link.source === node.name);
    const repliedCount = downstreamLinks
      .map((link) => link.value)
      .reduce((prevValue, currValue) => prevValue + currValue, 0);
    const noReplyCount = node.count - repliedCount;

    links.push({
      source: node.name,
      target: NO_REPLY,
      value: noReplyCount,
    });
    noReplyTotal += noReplyCount;
  }

  nodes.push({
    name: NO_REPLY,
    category: NO_REPLY,
    count: noReplyTotal,
  });
}

/**
 * Returns true if the sequence of job search events contains the path decribed by the eventTypeEdge.
 * @param {!JobData} jobData
 * @param {!Array<!EventType>} eventTypeEdge
 */
function isMatchingJobData({ job, jobSearchEvents }, eventTypeEdge) {
  return jobSearchEvents
    .map((jobSearchEvent) => jobSearchEvent.eventType)
    .join(";")
    .includes(eventTypeEdge.join(";"));
}

function getLast(array) {
  return array[array.length - 1];
}

const jobDatas = createJobDatas();
const eventTypeEdges = createEventTypeEdges(jobDatas);
const nodes = createNodes(eventTypeEdges);
const links = createLinks(jobDatas, nodes, eventTypeEdges);
addNoReplyNode(nodes, links);
const sankeyDataString = JSON.stringify({ nodes, links }, undefined, 1);
fs.writeFileSync(OUTPUT_FILE, sankeyDataString);
